### Question114 Unique Paths I
给定m行n列的网格，有一个机器人从左上角(0,0)出发，每一步可以向下或者向右走一步，
问有多少种方式走到右下角？

### Question115 Unique Paths II
给定m行n列的网格，有一个机器人从左上角(0,0)出发，每一步可以向下或者向右走一步，
网格中有些地方有障碍(为1表示有障碍)，机器人不能通过障碍格问有多少种不同的方式走到右下角

public int uniquePathsWithObstacles(int[][] A) {
}

### Question515 Paint House
有一排N栋房子，每栋房子要漆成3种颜色中的一种:红、蓝、绿
任何两栋相邻的厉子不能漆成同样的颜色
第i栋房子染成红色、蓝色、绿色的花费分别是cost[i][0], cost[i][1], cost[i][2]
例子︰
输入:
-N=3
-Cost =[14,2,11],[11,14,5],[14,3,10]]
输出:
-10(第0栋厉子蓝色，第1栋厉子绿色，第2栋厉子蓝色，2+5+3=10)
public int minCost(int[][] costs) {
}

### Question512
有一段由A-Z组成的字母串信息被加密成数字串，加密方式为:A -> 1, B -> 2,....,Z -> 26
给定加密后的数字串S[O...N-1]，问有多少种方式解密成字母串
例子∶
输入:
- 1221
输出∶
- 2(AB或者L)

### 最长连续单调子序列
### Question110 Minimum Path Sum
给定m行n列的网格，每个格子(i,j)里都一个非负数A[i][j]
求一个从左上角(0,0)到右下角的路径，每一步只能向下或者向右走一步，使得路径上的格子里的数字之和最小
输出最小数字和
public int getMin(int[][] nums) {
}

### Question553 Bomb Enemy
有一个M*N的网格，每个格子可能是空的，可能有一个敌人，可能有一堵墙
只能在某个空格子里放一个炸弹，炸弹会炸死所有同行同列的敌人，但是不能穿透墙
最多能炸死几个敌人
例子：
![](https://bhh-bucket.oss-cn-beijing.aliyuncs.com/pic/202210102254487.png)
输出：3

### Question516 Paint HouseII
描述
这里有n个房子在一列直线上，现在我们需要给房屋染色，共有k种颜色。
每个房屋染不同的颜色费用也不同，你希望每两个相邻的房屋颜色不同。
费用通过一个 n * k 的矩阵给出，
比如cost[0][0]表示房屋0染颜色0的费用，
cost[1][2]表示房屋1染颜色2的费用。
找到油漆所有房子的最低成本。
例子：
输入:
costs = [[14,2,11],[11,14,5],[14,3,10]]
输出: 10
说明:
三个屋子分别使用第1,2,1种颜色，总花费是10。

输入:
costs = [[5]]
输出: 5
说明：
只有一种颜色，一个房子，花费为5

public int minCostII(int[][] costs) {

}

### Question392 著名-小偷偷钱问题

### Question149 著名-股票问题

### Question76 最长序列

### Question513 完美平方
描述
给一个正整数 n, 请问最少多少个完全平方数(比如1, 4, 9...)的和等于n。

样例
样例 1:
输入: 12
输出: 3
解释: 4 + 4 + 4

样例 2:
输入: 13
输出: 2
解释: 4 + 9

### Question108 分割回文串（二）
描述：
给定字符串 s, 需要将它分割成一些子串, 使得每个子串都是回文串.
最少需要分割几次?

输入： s = "a"
输出： 0 （"a" 本身就是回文串, 无需分割）

输入： s = "aab"
输出： 1 （将 "aab" 分割一次, 得到 "aa" 和 "b", 它们都是回文串）

public int minCut(String s) {
// write your code here
}

### Question437 书籍复印
描述
给定n本书，第i本书有pages[i]页。有k个人来抄这些书。
这些书排成一行，每个人都可以索取连续一段的书。例如，
一个抄书人可以连续地将书从第i册复制到第j册，但是他不能复制第1册、第2册和第4册（没有第3册）。
他们在同一时间开始抄书，每抄一页书都要花1分钟。
为了让最慢的抄书人能在最早的时间完成书的分配，最好的策略是什么？
请返回最慢抄书人花费的最短时间。

输入: pages = [3, 2, 4], k = 2
输出: 5
解释: 第一个人复印前两本书, 耗时 5 分钟. 第二个人复印第三本书, 耗时 4 分钟.

输入: pages = [3, 2, 4], k = 3
输出: 4
解释: 三个人各复印一本书.

public int copyBooks(int[] pages, int k) {
// write your code here
}

### Question92 背包问题
描述
在 n 个物品中挑选若干物品装入背包，最多能装多满？
假设背包的大小为m，每个物品的大小为Ai（每个物品只能选择一次且物品大小均为正整数）

输入： 数组 = [3,4,8,5]
backpack size = 10
输出： 9
解释： 装4和5

输入： 数组 = [2,3,5,7]
backpack size = 12
输出： 12
解释： 装5和7.

public int backPack(int m, int[] a) {
// write your code here
}

### Question563 背包问题 V
描述
给出 n 个物品, 以及一个数组, nums[i] 代表第i个物品的大小, 
保证大小均为正数, 正整数 target 表示背包的大小, 找到能填满背包的方案数。
每一个物品只能使用一次

样例
给出候选物品集合 [1,2,3,3,7] 以及 target 7
结果的集合为:
[7]
[1,3,3]
返回 2

public int backPackV(int[] nums, int target) {
// write your code here
}

## 背包问题
### Question564 背包问题 VI
描述
给出 n 个物品, 以及一个数组, nums[i] 代表第i个物品的大小,
保证大小均为正数, 正整数 target 表示背包的大小, 找到能填满背包的方案数。
每个物品可以多次使用

样例
输人:A=[1,2,4],Target = 4
输出:6 (1+1+1+1=4,2+2=4,1+1+2=4,1+2+1=4,2+1+1=4,4=4)

public int backPackV(int[] nums, int target) {
// write your code here
}

### Question125 背包问题（二）
描述
有 n 个物品和一个大小为 m 的背包. 给定数组 A 表示每个物品的大小和数组 V 表示每个物品的价值.
问最多能装入背包的总价值是多大?

样例 1：
输入：
m = 10
A = [2, 3, 5, 7]
V = [1, 5, 2, 4]
输出：
9

解释：
装入 A[1] 和 A[3] 可以得到最大价值, V[1] + V[3] = 9


样例 2：
输入：
m = 10
A = [2, 3, 8]
V = [2, 5, 8]
输出：
10

解释：
装入 A[0] 和 A[2] 可以得到最大价值, V[0] + V[2] = 10

public int backPackII(int m, int[] a, int[] v) {
    // write your code here
}

### Question440 背包问题 III
dp[i][j] = max(dp[i - 1][j] + v)
描述
给定 n 种物品, 每种物品都有无限个. 第 i 个物品的体积为 A[i], 价值为 V[i].
再给定一个容量为 m 的背包. 问可以装入背包的最大价值是多少?

样例
样例 1:
输入: A = [2, 3, 5, 7], V = [1, 5, 2, 4], m = 10
输出: 15
解释: 装入三个物品 1 (A[1] = 3, V[1] = 5), 总价值 15.

样例 2:
输入: A = [1, 2, 3], V = [1, 2, 3], m = 5
输出: 5
解释: 策略不唯一. 比如, 装入五个物品 0 (A[0] = 1, V[0] = 1).

public int backPackIII(int[] a, int[] v, int m) {
    // write your code here
}